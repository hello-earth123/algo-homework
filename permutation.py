# N개중에서 R개를 뽑아서 나열한다.
# 순열은 앞에 나왔던 숫자를 제외하고 나머지가 올 수 있다.
arr = [1,2,3,4,5]
N = len(arr)
R = 3

# 해당 숫자가 사용되었는지 여부를 파악
visited = [False] * N
result = [0] * 3 # 출력 배열(뽑은 숫자를 순서대로 저장할 배열)

# 재귀 함수의 설계
# R개를 뽑아야 한다면, R개를 한 번에 뽑는 것이 아니라.
# 1개만 뽑고, 나머지 R-1개는 다음 재귀 호출에서 뽑는 
# 재귀 함수는 본인 위치에서 하나만 실행하고 나머지는 그 다음 함수한테 넘기는 구조
# 한 번에 하나만 처리하고, 나머지는 그 다음 재귀 호출에서 처리
# - ex) 0번 위치 하나만 뽑고, 나머지(1, 2, ... R-1)는 그 다음 재귀 함수가 처리
# - ex) 1번 위치 하나만 뽑고, 나머지(2, 3, .... R-1)는 그 다음 재귀 함수가 처리
# - ex) n번 위치 하나를 뽑았다면, 나머지는(n+1 ~, R-1 ) 그 다음 재귀 함수가 처리

# 재귀 함수
# - 구조 : 두 가지 파트로 나뉨
# - 1. 기저조건(base case) : 재귀함수가 끝나는 조건, 더 이상 자기 자신을 호출하지 않는 조건
# - 2. 유도조건 : 자기 자신을 다시 호출하는 경우

def perm(idx):
    # print(f'perm({idx}) start')
    # 1. 기저조건
    if idx == R: # 기저조건
        # 재귀 호출 하지 않음
        print(result)
        return # 함수를 종료
    
    # 2. 유도조건
    # 아직 뽑지 않은 숫자 중에서 숫자를 뽑고, 그 다음 숫자를 뽑으로 가야 함
    for i in range(N):
        if not visited[i]: # 5개 숫자 중에서 i번째를 뽑지 않았다면
            visited[i] = True # i 번째 숫자를 뽑는다.
            result[idx] = arr[i] # i번째 숫자를 idx번째
            perm(idx+1) # 그 다음 자리 수 뽑으로 가기
            visited[i] = False # 방문처리 초기화
    # print(f'perm({idx}) end')

# N개의 원소 중에서
# 0, 1, ..., R-1까지 뽑아야 함
perm(0) # 0번 위치 하나만 뽑고, perm(1) 호출


# 이 과정을 스택으로도 생각할 수 있어야 한다.